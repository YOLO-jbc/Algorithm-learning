# [567. Permutation in String](https://leetcode-cn.com/problems/permutation-in-string/)
## 题目
给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。

换句话说，第一个字符串的排列之一是第二个字符串的子串。

 
#### 示例 1：
```
输入: s1 = "ab" s2 = "eidbaooo"
输出: True
解释: s2 包含 s1 的排列之一 ("ba").
```
#### 示例 2：
```
输入: s1= "ab" s2 = "eidboaoo"
输出: False
```

## 思路
如果仅是检查s1是否是s2的字串，我可以用滑动窗口，KMP算法来解决，但是这里我们需要判断的是s1的排列是否是s2的字串，我们可以思考一下，一个字符串的排列与这个字符串本身有什么相同和不同：
- **包含的字符及其数量相同**
- 字符顺序不同

难道我们要将一个字符串的所有排列全部列出来一一去比较吗？（这种方法想想就不太高效哈哈哈哈），眼下我们需要思考的就是如何找出一个字符串的所有排列并和目标字符串去做比较，只要有一个比较成功就返回true。

还记得我们学习过一个数据结构**散列表**，它通过键-值对来记录数据，我们不妨用一个散列表来记录一段字符串，键为每个出现的**字符**，值为键字符在该段字符串中出现的**次数**，那么当两个字符串出现的字符及其次数都相同，也就是两个散列表相同，就可以说一个字符串的一种排列与另一个字符串相同了。

接下来我们只需要在s2上移动窗口，窗口的长度就是s1字符串的长度，每次移动窗口，便维护窗口所对应字符串的散列表，若此时窗口的散列表与s1字符串的散列表相同，则返回true。

```cpp
#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    //!a permutation of s1 is a substring of s2
    bool checkInclusion(string s1, string s2) {
        map<char,int>mp1;
        map<char,int>mp2;
        int size1=s1.size(),size2=s2.size();
        if(size1>size2)
        {
            return false;
        }
        for(int i=0;i<size1;i++)
        {
            mp1[s1[i]]++;   //建立s1的散列表
            mp2[s2[i]]++;
        }
        if(mp1==mp2)
            return true;
        for(int i=size1;i<size2;i++)
        {
            mp2[s2[i]]++;
            mp2[s2[i-size1]]--;
            if(mp2[s2[i-size1]]==0)     //出现次数为0则删除
            {
                auto item=mp2.find(s2[i-size1]);
                mp2.erase(item);
            }
            if(mp2==mp1)
                return true;
        }
        return false;
    }
};
int main()
{
    Solution sol;
    string instr1="ab";
    string instr2="eidboaoo";
    cout<<sol.checkInclusion(instr1,instr2)<<endl;
}
```