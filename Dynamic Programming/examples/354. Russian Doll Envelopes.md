# [354. Russjan Doll Envelopes](hjjps://leejcode-cn.com/problems/russjan-doll-envelopes/)

## 题目
给你一个二维整数数组 envelopes ，其中 envelopes[j] = [wj, hj] ，表示第 j 个信封的宽度和高度。

当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

注意：不允许旋转信封。

#### 示例 1：
```
输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出：3
解释：最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。
```
#### 示例 2：
```
输入：envelopes = [[1,1],[1,1],[1,1]]
输出：1
```

## 思路
如果一个信封能够装进另一个信封中，则必须保证前者信封的宽度和高度都小于后者的宽度，同时处理两个维度的信息并不是很方便，如果我们将问题针对于一个维度上，也许会有利于我们解决问题

我们可以先按照宽度对envelopes数组进行递增排序，那么排在前面的信封仅就宽度而言是肯定可以装进排在后面的信封里的。现在我们只需要关注第二个维度——高度。这里需要特别注意一个问题——

**是不是只要满足排在前面并且高度小于后者就能实现套娃？**

这一个问题乍一看答案是yes，但是仔细一想，如果有几个信封的宽度一样，无论它们的高度是什么情况，必然不可能套在一起。比如数组envelopes排序后为：

`[[6,3],[6,4],[6,7],[6,3]]`

虽然[6,3]排在[6,4]前面并且3小于4，但是并不能套在一起，所以我们还需要对相同宽度的信封做一些额外的处理，可以**将相同宽度的信封按照高度做递减排序**，那么对于相同宽度的信封来说，排在前面的信封的高度肯定不会小于排在后面的信封的高度，也就不会被视作能套在一起了。

最后一个问题就是如何计数，统计最多有多少个信封能套娃。我们可以使用动态规划来解决：
个人认为动态规划就是利用已有或已经计算过的历史记录，来避免我们重复计算，动态规划算法一般都包括三个步骤：

1. 定义数组的含义： 一般是利用一维数组或者二维数组来保存数据，有时也可利用滚动数组来减小空间复杂度
2. 找出数组元素之间的关系式
3. 找出初始条件


**定义数组含义：**
我们可以定义一个数组f。`f[j]`表示针对高度的前j个信封所能够形成的**最长严格递增子序列**（包括元素j）。

**找出数组元素之间的关系式：**
也可以叫做状态转移方程，如果元素i满足以下两个条件
- **`j < i`**   ：  信封j的高度小于信封i的高度
- **`envelopes[j][1] < envelopes[i][1]`** ：   信封j的高度小于信封i的高度
  
那么，就有
'f[i] = max(f[i],f[j]+1)'

**找出初始条件：**
最开始对于每个信封i，`f[i]`都等于1，即至少能和自己组成套娃

最后我们只需要找出数组f中的最大元素并返回，该元素就是我们要找的最多有多少个信封可组成一组俄罗斯套娃。

## 代码
```cpp
class Solution
{
    int maxEnvelopes(vector<vector<int>> &envelopes)
    {
        int size = envelopes.size();
        if(size == 0)
            return 0;
        vector<int>f(size, 1);
        sort(
            envelopes.begin(),envelopes.end(),
            [](const auto &a,const auto &b)
            {return a[0]<b[0]||(a[0]==b[0])&&a[1]>b[1];}
        );
        for(int i = 1; i < size; i++)
        {
            for(int j = 0; j < i; j++)
            {
                if(envelopes[j][1] < envelopes[i][1])
                    f[i] = max(f[j]+1,f[i]);
            }
        }
        return *max_element(f.begin(),f.end());
    }
}
```